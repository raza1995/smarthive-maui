import axios from "axios";
import {
  integrationsNames,
  malwareByteApiUrls,
} from "../../../utils/constants";
import malwareBytesEndpointModel from "./endpoints.model";
import { getMalwareBytesStatusApi } from "../../../api/malwareBytes";
import { getMalwareBytesAccessToken } from "../../services/MalwareBytes/malwareByteServices";
import { getAllCompaniesHaveIntegration } from "../../../Mysql/Companies/company.service";
import { CliProgressBar } from "../../../utils/cliProgressBar";
import { fetchAndSaveEndpointAssetsData } from "../EndpointAssets/endpointAssets.controller";
import { errorHandler } from "../../../utils/errorHandler";

const updateOrCreate = async (
  items,
  company_id,
  account_id,
  integrationCategoryType,
  baseURL,
  token
) => {
  try {
    console.log("Number of items ", items.length);
    let i = 0;
    const startTime = new Date();
    for await (const item of items) {
      const status = await getMalwareBytesStatusApi(
        baseURL,
        token,
        item.agent.account_id,
        item?.machine?.id
      );
      await malwareBytesEndpointModel.updateOne(
        {
          link: item.link,
          company_id,
          account_id,
          integration_category_type: integrationCategoryType,
        },
        {
          company_id,
          status,
          account_id,
          integration_category_type: integrationCategoryType,
          ...item,
        },
        {
          upsert: true,
        }
      );
      // Save Endpoint Assets start
      await fetchAndSaveEndpointAssetsData(
        baseURL,
        token,
        item.agent.account_id,
        company_id,
        item?.machine?.id,
        item?.link
      );
      // Save Endpoint Assets ends

      CliProgressBar(
        `Malwarebytes endpoints for company Id ${company_id}`,
        i,
        items.length
      );
      i++;
    }
    console.log("done...");
    return true;
  } catch (err) {
    errorHandler(err);
    return false;
  }
};
const fetchAll = (
  token,
  account_id,
  company_id,
  integrationCategoryType,
  baseURL
) =>
  new Promise((resolve) => {
    axios
      .post(
        `${baseURL}/${malwareByteApiUrls.endPoints}`,
        {
          account_ids: [account_id],
        },
        {
          headers: {
            authorization: `Bearer ${token}`,
          },
        }
      )
      .catch((error) => resolve(error))
      .then(async (response) => {
        if (response?.data?.endpoints?.length > 0) {
          try {
            await updateOrCreate(
              response?.data?.endpoints,
              company_id,
              account_id,
              integrationCategoryType,
              baseURL,
              token
            );

            resolve(response.data);
          } catch (err) {
            resolve(err);
          }
        } else {
          resolve("No data");
        }
      });
  });

export const getEndpointsOfCompany = async (company) => {
  if (company.integrations) {
    const malwareByteIntegration = company?.integrations?.integration_values;
    const baseURL = company.integrations?.integrations_base_url?.base_url;
    if (malwareByteIntegration?.client_secret) {
      const integrationCategoryType =
        company?.integrations.integration_category_type;
      const client_secret = malwareByteIntegration?.client_secret;
      const client_id = malwareByteIntegration?.client_id;
      const account_ids = malwareByteIntegration?.account_ids;
      const AccessData = await getMalwareBytesAccessToken(
        client_id,
        client_secret,
        baseURL
      );
      if (AccessData.status === 200) {
        const oldAssets = await malwareBytesEndpointModel
          .find({
            company_id: company.id,
            integration_category_type: integrationCategoryType,
          })
          .sort({ updatedAt: -1 });
        const lastUpdatedAtDate = oldAssets?.[0]?.updatedAt;
        for await (const account_id of account_ids) {
          console.log("lastUpdatedAtDate", lastUpdatedAtDate);
          let next_cursor = null;
          do {
            const resp = await fetchAll(
              AccessData.data.access_token,
              account_id,
              company.id,
              integrationCategoryType,
              baseURL
            );
            console.log("total_count", resp?.total_count);
            if (resp?.next_cursor) {
              next_cursor = resp?.next_cursor;
            } else {
              next_cursor = null;
            }
          } while (next_cursor != null);
        }
        if (oldAssets.length > 0) {
          const deleteAssets = await malwareBytesEndpointModel.deleteMany({
            company_id: company.id,
            integration_category_type: integrationCategoryType,
            updatedAt: { $lte: lastUpdatedAtDate },
          });
          console.log("delete assets", deleteAssets.deletedCount);
        }
      } else {
        console.log("unauthorized");
      }
    }
  }
};

export const getEndpoints = async (req, res) => {
  try {
    const Companies = await getAllCompaniesHaveIntegration(
      integrationsNames.MALWAREBYTES
    );
    if (Companies.length > 0) {
      if (res) {
        res.send("Malware endpoint data start successfully");
      }
      for await (const company of Companies) {
        await getEndpointsOfCompany(company);
      }
    } else if (res) {
      res.send("success");
    }
  } catch (error) {
    errorHandler(error);
    if (res) {
      res.status(500).json(error);
    }
  }
};
