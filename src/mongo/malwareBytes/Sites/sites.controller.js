import axios from "axios";
import httpStatus from "http-status-codes";
import malwareBytesApi from "../../../api/malwareBytes";
import {
  automoxApiUrls,
  integrationsNames,
  malwareByteApiUrls,
} from "../../../utils/constants";
import siteModel from "./site.model";
import {
  findMalwareBytesBaseUrlAndGetAccessToken,
  getMalwareBytesAccessToken,
} from "../../services/MalwareBytes/malwareByteServices";
import { findUserOAuthId } from "../../../Mysql/Users/users.service";
import {
  getAllCompaniesHaveIntegration,
  getCompanyHaveIntegration,
} from "../../../Mysql/Companies/company.service";
import { errorHandler } from "../../../utils/errorHandler";
import automoxAPI, { automoxClientAPI } from "../../../api/automox";
import { addEventLog } from "../../../Mysql/Logs/eventLogs/eventLogs.controller";
import { integrationCreateActivity } from "../../../Mysql/Logs/ActivitiesType/integrationActivity";

const updateOrCreate = async (items, company_id) => {
  try {
    console.log("Number of items ", items.length);
    for await (const item of items) {
      await siteModel.updateOne(
        { id: item.id },
        { company_id, ...item },
        {
          upsert: true,
        }
      );
    }
    console.log("done...");
    return true;
  } catch (err) {
    errorHandler(err);
    return false;
  }
};
const fetchAll = (baseURL, token, account_id, company_id) =>
  new Promise((resolve, reject) => {
    axios
      .get(`${baseURL}/${malwareByteApiUrls.sites}`, {
        headers: {
          authorization: `Bearer ${token}`,
        },
      })
      .catch((error) => resolve(error))
      .then((response) => {
        if (response?.data?.sites?.length > 0) {
          if (updateOrCreate(response?.data?.sites, company_id)) {
            resolve(response.data);
          } else {
            resolve("Error occured");
          }
          resolve(response.data);
        } else {
          resolve("No data");
        }
      });
  });

export const getSites = async (req, res) => {
  try {
    let pageUrl = null;

    const Companies = await getAllCompaniesHaveIntegration(
      integrationsNames.MALWAREBYTES
    );
    if (Companies) {
      for await (const company of Companies) {
        const malwareByteIntegration = company.integrations.integration_values;
        const baseURL = company.integrations?.integrations_base_url?.base_url;
        if (malwareByteIntegration?.client_secret) {
          do {
            const client_secret = malwareByteIntegration?.client_secret;
            const client_id = malwareByteIntegration?.client_id;
            const account_id = malwareByteIntegration?.account_id;
            const info = await getMalwareBytesAccessToken(
              client_id,
              client_secret
            );
            if (info.status === 200) {
              const resp = await fetchAll(
                baseURL,
                info.data.access_token,
                account_id,
                company.id
              );
              // console.log(resp);
              if (resp?.next_cursor) {
                pageUrl = info.next_cursor;
              } else {
                pageUrl = null;
              }
            } else {
              console.log("unauthorized");
            }
          } while (pageUrl != null);
        }
      }
    }
    res.send("success");
  } catch (error) {
    errorHandler(error);
    res.status(500).json(error);
  }
};

export const getMalwareByteIntegrationSites = async (req, res) => {
  try {
    const malwareByteIntegration = req.body;
    if (malwareByteIntegration?.client_secret) {
      const client_secret = malwareByteIntegration?.client_secret;
      const client_id = malwareByteIntegration?.client_id;
      const info = await findMalwareBytesBaseUrlAndGetAccessToken(
        client_id,
        client_secret
      );
      console.log(info);
      if (info.valid) {
        const resp = await axios
          .get(`${info.data.baseURL}/${malwareByteApiUrls.sites}`, {
            headers: {
              authorization: `Bearer ${info.data.access_token}`,
            },
          })
          .then((response) => response.data);

        const sites = await Promise.all(
          resp.sites.map(async (site) => {
            const siteAssets = await axios
              .post(
                `${info.data.baseURL}/${malwareByteApiUrls.endPoints}`,
                {
                  account_ids: [site.account_id],
                },
                {
                  headers: {
                    authorization: `Bearer ${info.data.access_token}`,
                  },
                }
              )
              .then((response) => response.data);
            return {
              company_name: site.company_name,
              account_id: site.account_id,
              account_status: site.account_status,
              total_devices: siteAssets.total_count,
            };
          })
        );
        // console.log(resp);
        res.status(httpStatus.OK).json({ sites });
      } else {
        res.status(httpStatus.BAD_REQUEST).json({
          statusCode: info.status,
          error: "Unauthorized",
          message: "invalid credentials",
        });
      }
    } else {
      res.status(httpStatus.BAD_REQUEST).json({
        error: "Unauthorized",
        message: "invalid credentials",
      });
    }
  } catch (err) {
    // console.log("Error occured", err);
    res
      .status(httpStatus.INTERNAL_SERVER_ERROR)
      .json({ valid: false, error: err.message });
  }
};

export const getMalwareByteIntegrationDetails = async (req, res) => {
  try {
    const loggedInUser = req.user;
    const { type } = req.params;
    const user = await findUserOAuthId(loggedInUser.sub);
    const integration = await getCompanyHaveIntegration(
      user.company_id,
      integrationsNames.MALWAREBYTES,
      type
    );
    const malwareByteIntegration =
      integration?.integrations?.integration_values;
    const baseURL = integration.integrations?.integrations_base_url?.base_url;
    if (malwareByteIntegration?.client_secret) {
      const client_secret = malwareByteIntegration?.client_secret;
      const client_id = malwareByteIntegration?.client_id;
      const info = await getMalwareBytesAccessToken(
        client_id,
        client_secret,
        baseURL
      );
      console.log(info);
      if (info.status === 200) {
        const sites = await Promise.all(
          malwareByteIntegration?.sites?.map(async (site) => {
            const installers = await axios
              .get(`${baseURL}/v1/accounts/${site.account_id}/installers`, {
                headers: {
                  authorization: `Bearer ${info.data.access_token}`,
                },
              })
              .then((response) => response.data);
            return {
              ...site,
              installers,
            };
          })
        );
        // console.log(resp);
        res.status(httpStatus.OK).json({ sites });
      } else {
        res.status(httpStatus.BAD_REQUEST).json({
          error: "Unauthorized",
          message: "invalid credentials",
        });
      }
    } else {
      res.status(httpStatus.BAD_REQUEST).json({
        error: "Unauthorized",
        message: "invalid credentials",
      });
    }
  } catch (err) {
    errorHandler(err);
    res
      .status(httpStatus.INTERNAL_SERVER_ERROR)
      .json({ valid: false, error: err.message });
  }
};

export const getAutomoxIntegrationSites = async (req, res) => {
  const { user } = req;
  try {
    const automoxIntegration = req.body;
    if (automoxIntegration?.account_id) {
      const account_id = automoxIntegration?.account_id;
      const access_token = automoxIntegration?.access_token;
      const resp = await automoxClientAPI
        .get(`${automoxApiUrls.zones}/${account_id}/zones?limit=500`, {
          headers: {
            authorization: `Bearer ${access_token}`,
          },
        })
        .then((response) => response?.data?.data);
      res.status(httpStatus.OK).json({ resp });
    } else {
      res.status(httpStatus.BAD_REQUEST).json({
        error: "Unauthorized",
        message: "Invalid Credentials",
      });
    }
  } catch (err) {
    addEventLog(
      {
        id: user.id,
        email: user.email,
        company_id: user.company_id,
        ipAddress: req.socket.remoteAddress,
        process: `Verify automox credentials`,
        user_id: null,
      },
      integrationCreateActivity.status.integrationCreatingFailed.code,
      null,
      "Invalid Credentials"
    );
    res
      .status(httpStatus.INTERNAL_SERVER_ERROR)
      .json({ valid: false, error: err.message });
  }
};

export const verifyAutomoxZone = async (req, res) => {
  try {
    const automoxIntegration = req.body;
    const { user } = req;
    if (automoxIntegration?.organization_id) {
      const url = `servers?o=${automoxIntegration?.organization_id}`;
      const resp = await automoxAPI
        .get(url)
        .then((response) => {
          res.status(httpStatus.OK).json({ data: response?.data });
        })
        .catch((err) => {
          addEventLog(
            {
              id: user.id,
              email: user.email,
              company_id: user.company_id,
              ipAddress: req.socket.remoteAddress,
              process: `Verify automox credentials`,
              user_id: null,
            },
            integrationCreateActivity.status.integrationCreatingFailed.code,
            null,
            err?.message || "Invalid credentials"
          );
          errorHandler(err);
          res.status(httpStatus.BAD_REQUEST).json({
            error: "Unauthorized",
            message: "Invalid Zone ID",
          });
        });
    } else {
      res.status(httpStatus.BAD_REQUEST).json({
        error: "Unauthorized",
        message: "Invalid Zone ID",
      });
    }
  } catch (err) {
    errorHandler(err);
    res
      .status(httpStatus.INTERNAL_SERVER_ERROR)
      .json({ valid: false, error: err.message });
  }
};
