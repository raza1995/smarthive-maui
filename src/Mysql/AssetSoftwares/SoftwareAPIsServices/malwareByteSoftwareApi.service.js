import { groupBy } from "lodash";
import { Op } from "sequelize";
import cvesModel from "../../../mongo/malwareBytes/Cves/cves.model";
import malwareBytesEndpointAssetsModel from "../../../mongo/malwareBytes/EndpointAssets/endpointAssets.model";
import { CliProgressBar } from "../../../utils/cliProgressBar";
import { integrationsNames } from "../../../utils/constants";
import { errorHandler } from "../../../utils/errorHandler";
import { getCompanyAssetsForParticularSource } from "../../Assets/assets.service";
import { updateOrCreateMalwarePatching } from "../../Patch/patch.controller";
import assetSoftwareSQLModel from "../assetSoftware.model";
import { updateOrCreateAssetSoftware } from "../assetSoftware.service";

const fetchAll = async (device, integration, company_id, asset_id) => {
  console.log("fetcjh all", asset_id, device.device_id, company_id);
  const endpointAsset = await malwareBytesEndpointAssetsModel
    .find({
      company_id,
      id: device.device_id,
    })
    .then((response) => JSON.parse(JSON.stringify(response)));
  const assetSoftwares = endpointAsset[0].software_installed;
  const functionStartTime = new Date();
  const softwaresGroupByName =
    assetSoftwares.length > 0 ? groupBy(assetSoftwares, "product") : [];
  const soft = Object.keys(softwaresGroupByName).map(
    async (softwareName) => softwaresGroupByName[softwareName]
  );
  //   await Promise.all(
  //     Object.keys(softwaresGroupByName).map(async (softwareName) => {
  //   const softwares = softwaresGroupByName[softwareName];
  let j = 1;
  for await (const softwares of soft) {
    let i = 1;
    for await (const item of softwares) {
      item.os_name = endpointAsset[0]?.os_info?.os_release_name;
      item.os_version = endpointAsset[0]?.os_info?.os_version;
      await updateOrCreateAssetSoftware(
        { ...item, vendor_name: item?.vendor || "unknown", name: item.product },
        asset_id,
        company_id,
        i
      );
      i++;
    }
  }
  CliProgressBar(`Saving software of MalwareBytes`, j, soft.length + 1);
  j++;
  //     })
  //   );
};

const fetchAllCves = async (device, integration, company_id, asset_id) => {
  const endpointAsset = await malwareBytesEndpointAssetsModel
    .find({
      company_id,
      id: device.device_id,
    })
    .then((response) => JSON.parse(JSON.stringify(response)));
  const link = device?.device_id.split("/");
  const deviceId = link[link.length - 1];
  const endpointCves = await cvesModel.find({
    company_id,
    machine_id: deviceId,
    account_id: endpointAsset[0].account_id,
  });
  const softwaresInstalled = endpointAsset[0]?.software_installed;
  if (endpointCves.length > 0) {
    const softwares = endpointCves;
    for (let i = 0; i < softwares.length; i++) {
      // for(let i = 0; i < 1; i++) {
      const software = softwares[i];
      const item = {};
      const version = softwaresInstalled.filter(
        (softwareItem) => softwareItem.product === software.product
      );
      const updateAvailable = endpointAsset[0]?.updates_available.filter(
        (endpointItem) => endpointItem.product === software.product
      );

      item.os_name = endpointAsset[0]?.os_info?.os_release_name;
      item.os_version = endpointAsset[0]?.os_info?.os_version;
      item.os_family = endpointAsset[0]?.os_info?.os_platform;
      item.name = software.product;
      item.description = software.description;
      item.vendor = software.vendor;
      item.severity = software.severity;
      // item.version = software.installed_version;
      item.version = version[0]?.update?.version;
      item.product = software.product;
      // let patchAvailableDate = new Date(software.created_at * 1000);

      // item.patch_available_timestamp = moment(patchAvailableDate).format();
      item.patch_available_timestamp = software.created_at;
      // console.log("patch_available_timestampaa", item.patch_available_timestamp)
      // item.requires_reboot = updateAvailable[0]?.reboot_required
      // console.log("version[0]?.update?.version", version[0]?.update?.version)
      await updateOrCreateMalwarePatching(
        { ...item, cves: [software.cve_id], name: item.product },
        asset_id,
        company_id
      );
      // }
    }
    // }
  }
};
export const getAndSaveMalwareByteSoftwareForCompany = async (
  company,
  integration
) => {
  try {
    const malwareByteIntegration = integration?.dataValues;
    const orgDevices = await getCompanyAssetsForParticularSource(
      company.id,
      integrationsNames.MALWAREBYTES
    );

    for await (const device of orgDevices) {
      if (malwareByteIntegration?.integration_values?.account_ids.length > 0) {
        const oldData = await assetSoftwareSQLModel.findOne({
          where: { company_id: company.id, asset_id: device.id },
          order: [["updatedAt", "DESC"]],
        });
        const lastUpdatedAtDate = oldData?.updatedAt;
        console.log("lastUpdatedAtDate", lastUpdatedAtDate);
        const info = await fetchAll(
          device.asset_sources[0],
          malwareByteIntegration,
          company.id,
          device?.id
        );
        await fetchAllCves(
          device.asset_sources[0],
          malwareByteIntegration,
          company.id,
          device?.id
        );
        if (lastUpdatedAtDate) {
          const deleteAssets = await assetSoftwareSQLModel.destroy({
            where: {
              company_id: company.id,
              asset_id: device.id,
              updatedAt: { [Op.lte]: lastUpdatedAtDate },
            },
          });
          console.log("delete softwares", deleteAssets);
        }
      }
    }
  } catch (err) {
    errorHandler(err);
  }
};
